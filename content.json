{"meta":{"title":"你好,世界","subtitle":null,"description":null,"author":"zzzmj","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-11-29T09:54:42.000Z","updated":"2019-01-21T02:41:09.096Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-12-20T11:52:24.000Z","updated":"2019-02-26T10:41:05.847Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一些项目的展示 标题 描述 预览 使用技术 love-me 小游戏 https://zzzmj.github.io/demo/love-me/main.html native-js slide 轮播图 https://zzzmj.github.io/demo/slide/index.html native-js comment 留言版 https://zzzmj.github.io/demo/comment/index.html native-js city-search 城市搜索 https://zzzmj.github.io/demo/city-serach/index.html native-js 在ife中做的一些项目 标题 描述 预览 使用技术 three-types-resumes 用一份html代码实现三种样式 https://zzzmj.github.io/ife/three-types-resumes/resume.html native-js"},{"title":"tags","date":"2018-11-29T09:48:42.000Z","updated":"2019-01-21T02:40:51.634Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"projects_url","date":"2018-12-20T11:52:51.000Z","updated":"2018-12-20T11:52:52.001Z","comments":true,"path":"projects-url/index.html","permalink":"http://yoursite.com/projects-url/index.html","excerpt":"","text":""}],"posts":[{"title":"js实现拖拽效果（二）：面向对象封装","slug":"js实现拖拽效果（二）：面向对象封装","date":"2019-06-14T07:53:41.000Z","updated":"2019-06-14T07:54:20.269Z","comments":true,"path":"2019/06/14/js实现拖拽效果（二）：面向对象封装/","link":"","permalink":"http://yoursite.com/2019/06/14/js实现拖拽效果（二）：面向对象封装/","excerpt":"","text":"1. 前言在上一篇文章中，已经实现了拖拽的效果，但并不利用复用，我们使用面向对象的方式，将代码重构一遍。 2. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667(function() &#123; function Drag(selector) &#123; // 传进来的如果是DOM对象则不用再查找 this.elem = typeof selector == 'object' ? selector : document.querySelector(selector) // 鼠标在盒子内部的偏移 this.innerDis = &#123;&#125; this.init() &#125; Drag.prototype = &#123; constructor: Drag, init: function() &#123; this.handleDrag() &#125;, getStyle: function()&#123; return window.getComputedStyle(this.elem, null) &#125;, getTargetPos: function() &#123; var elemStyle = this.getStyle() var pos = &#123; x: parseInt(elemStyle.left.slice(0, -2)), y: parseInt(elemStyle.top.slice(0, -2)) &#125; return pos &#125;, setTargetPos: function(pos) &#123; this.elem.style.left = pos.x this.elem.style.top = pos.y return this.elem &#125;, handleDrag: function() &#123; var self = this function start(event) &#123; var divPos = self.getTargetPos() // 鼠标按下的时候，记录鼠标在div内部的距离 var innerDis = &#123; x: event.clientX - divPos.x, y: event.clientY - divPos.y &#125; self.innerDis = innerDis // 注意必须绑定在document对象上，如果绑定在box对象上，当鼠标脱快了移出box盒子时，就会产生BUG document.addEventListener('mousemove', move, false) document.addEventListener('mouseup', end, false) &#125; function move(event) &#123; // 拖动元素的新位置 = 鼠标移动到的新位置 - 鼠标在div的内部距离 var pos = &#123; x: (event.clientX - self.innerDis.x) + 'px', y: (event.clientY - self.innerDis.y) + 'px', &#125; self.setTargetPos(pos) &#125; function end() &#123; document.removeEventListener('mousemove', move) document.removeEventListener('mouseup', end) &#125; this.elem.addEventListener('mousedown', start) &#125; &#125; window.Drag = Drag&#125;)()new Drag('.box') 还可以写成jquery插件的形式 添加上代码12345678910(function ($) &#123; $.fn.extend(&#123; becomeDrag: function () &#123; new Drag(this[0]); return this; // 保证链式访问 &#125; &#125;)&#125;)(jQuery);$('.box').becomeDrag()","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"js实现拖拽效果（一）：原理实现","slug":"js实现拖拽效果（一）：原理实现","date":"2019-06-14T07:53:32.000Z","updated":"2019-06-14T07:53:59.553Z","comments":true,"path":"2019/06/14/js实现拖拽效果（一）：原理实现/","link":"","permalink":"http://yoursite.com/2019/06/14/js实现拖拽效果（一）：原理实现/","excerpt":"","text":"1. 原理JS 拖拽一个元素的原理：首先要明白三个值 鼠标的位置A = {x, y} 盒子的位置B = {x, y} 鼠标在盒子内的距离C = {A.x - B.x, A.y - B.y} 涉及到三个鼠标事件 鼠标按下时，mousedown 鼠标移动时，mousemove 鼠标松开时，mouseup 然后就可以开始讲明实现过程了 鼠标按下的时候，计算出C，鼠标在盒子里距离（鼠标位置 - 盒子位置） 鼠标移动的时候，更新盒子位置 B = A - C 鼠标松开的时候，关闭2, 3过程的两个鼠标监听器 2. 代码实现html123&lt;div class=\"box\"&gt;&lt;/div&gt; css123456789101112.box &#123; position: absolute; width: 100px; height: 100px; left: 10px; top: 10px; background-color: beige;&#125;.box:hover &#123; cursor: move;&#125; js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var box = document.querySelector('.box')// 获取元素的样式var getStyle = function(element)&#123; return window.getComputedStyle(box, null)&#125;// 获取目标元素的位置var getTargetPos = function(elem) &#123; var elemStyle = getStyle(elem) var pos = &#123; x: parseInt(elemStyle.left.slice(0, -2)), y: parseInt(elemStyle.top.slice(0, -2)) &#125; return pos&#125;// 设置目标元素的位置var setTargetPos = function(elem, pos) &#123; elem.style.left = pos.left elem.style.top = pos.top return elem&#125;box.addEventListener('mousedown', function(event) &#123; var divPos = getTargetPos(box) var mousePos = &#123; x: event.clientX, y: event.clientY &#125; // 鼠标按下的时候，记录鼠标在div内部的距离 var innerDis = &#123; x: event.clientX - divPos.x, y: event.clientY - divPos.y &#125; var move = function(event) &#123; // 鼠标移动到的新位置 - 鼠标在div的内部距离 即是拖动元素的新位置 setTargetPos(box, &#123; left: (event.clientX - innerDis.x) + 'px', top: (event.clientY - innerDis.y) + 'px', &#125;) &#125; var end = function() &#123; document.removeEventListener('mousemove', move) document.removeEventListener('mouseup', end) &#125; // 必须绑定在document对象上，如果绑定在box对象上，当鼠标脱快了移出box盒子时，就会产生BUG document.addEventListener('mousemove', move, false) document.addEventListener('mouseup', end, false)&#125;) 这样做实现了效果，但并不利用复用 下一篇文章会对我们的拖拽效果进行封装","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"js获取元素的left和top值方法总结","slug":"js获取元素的left和top值方法总结","date":"2019-06-14T02:30:19.000Z","updated":"2019-06-14T02:47:17.553Z","comments":true,"path":"2019/06/14/js获取元素的left和top值方法总结/","link":"","permalink":"http://yoursite.com/2019/06/14/js获取元素的left和top值方法总结/","excerpt":"","text":"方法一：使用obj.style.left和obj.style.top 该方法获取到的样式可读可写 但是这种方法有局限性，仅能获取行内样式中的left，right。如果写在了style标签里，或者link引入的css文件中，则获取不到 方法二：使用window.getComputedStyle该方法接收两个参数第一个参数是，要获取样式的元素第二个是可选参数，要匹配的伪元素的字符串 用法123var box = document.querySelector('.box')var boxStyle = window.getComputedStyle(box, null)console.log(boxStyle.left + ' ' + boxStyle.top) 该方法获取到的样式是可读不可写的 方法三：使用obj.offsetLeft和obj.offsetTop 12var box = document.querySelector('.box')console.log(box.offsetLeft + ' ' + box.offsetTop) 该方法可读不可写","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"2019年团体程序设计天梯赛总结","slug":"2019年团体程序设计天梯赛总结","date":"2019-03-31T03:45:23.000Z","updated":"2019-03-31T03:54:04.437Z","comments":true,"path":"2019/03/31/2019年团体程序设计天梯赛总结/","link":"","permalink":"http://yoursite.com/2019/03/31/2019年团体程序设计天梯赛总结/","excerpt":"","text":"从寒假开始，我很少碰竞赛相关的题目了，感觉已经没有了以前的热情，直到dxl在群里提出参加天梯赛一事时，团体提出了搞天梯赛，一开始我是不想去的，感觉自己退步了很多，不想再参与之类的竞赛。但回头想想蓝桥杯也是需要刷题的，训练一下算法，对两个比赛都有好处。于是还是去尝试的参加了一下选拔赛，发现成绩还可以，后来团队也开始讨论江西各大高校实力，天梯赛相关的事情。不知为何，我突然被点起了热情，也想看看我们学校和江西其他高校的差距（争强好胜？哈哈(#^.^#)），经过重重选拔，侥幸的进入了一队（爱，死亡与机器人） 然后就是坐车去南昌，大家一起找地方住，住宾馆的时候大家都在讨论分房间的事情，两个两个的约好了一起住，由于我与团队脱节太久，寒假至比赛期间我很少在团队里说话，和团队的人接触。住宾馆的时候，16级就我落单了。大家都找好了小伙伴，后来安排了我和一个17级的学弟住，心里还挺不是滋味的。在睡觉的时候想了想，原因大概就是自己不说话，诶，其实我以前还挺活跃的。 比赛当天，心情还是很紧张的，担心拖大家的后腿。做题的时候前面还是比较顺利，L1难度的题都比较简单，但L1-8题，我看了一下，通过率好低，大概只有0.02%，我当时就觉得这道题绝壁有坑，我打算跳过这题的时候，看了一下我们队的分值还没到800，这可咋办，没到800分就没有进阶奖励，我硬着头皮准备把这道20分的题混个十多分，是字符串处理的题，我是用java写的，因为java处理字符串我比较熟悉，坑点很多，我大概提交了五六遍都只拿到一分，我打算放弃的时候，想了想，再试最后几次把，这道题没分的话，后面做了也没有用，仔细分析了下样例特殊情况，最终拿到了11分（花了好长时间┭┮﹏┭┮），立马转战L2。 L2-1读完感觉应该不会卡时间，暴力加set后直接拿了25分，有些意外，看了下L2-3应该是道广搜题，简单想了下思路，应该是要vetor建立图，我好久没做这种题，时间也不允许了，就放弃了，L2-4题目很长，看了一遍发现是道水题，用栈混了19分，可能特殊情况没考虑全。时间也差不多结束了，就没再做了，看了看排名，团队拿了1080分，我个人拿了133分。后续大家说能拿二等奖，(^o^)/~，还挺开心的 这次天梯赛感悟很多，期间团队也经历了很多很多波折，团队发展至今不易，很多时候都是雷老师一人在支撑这个团队，其实我个人觉得编程能力只是很小的一部分，想提升自己，光靠技术是行不通的，应该多多关注其他方面的能力，多多在团队里说话，听雷老师的教诲，这些比技术来说更加可贵。 希望团队以后发展越来越好，学弟学妹们能扛起大旗，在下一届比赛创造更好的成绩。","categories":[{"name":"感悟","slug":"感悟","permalink":"http://yoursite.com/categories/感悟/"}],"tags":[{"name":"天梯赛","slug":"天梯赛","permalink":"http://yoursite.com/tags/天梯赛/"}]},{"title":"用CSS画一个带阴影的三角形","slug":"用CSS画一个带阴影的三角形","date":"2019-03-04T05:40:09.000Z","updated":"2019-03-04T05:40:39.349Z","comments":true,"path":"2019/03/04/用CSS画一个带阴影的三角形/","link":"","permalink":"http://yoursite.com/2019/03/04/用CSS画一个带阴影的三角形/","excerpt":"","text":"1. 思路怎么用CSS画一个带阴影的三角形呢 ?有童鞋说, 这还不简单吗网上有很多解决方案, 但其实大多都是实现不太完美的, 存在一些问题 假设我们做一个向下的三角形箭头常见的方法大致有两种 通过边框控制, border-left和border-right设为透明, border-top设为预定的颜色即可 通过 transform 旋转盒子 方法一可以画三角形, 但是画阴影是很难做到的(如果做到的朋友, 欢迎给我留言) 2. 设计2.1 边框法html结构123&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt; css样式12345678910111213141516.box &#123; position: relative; width: 200px; height: 100px; background: #ff8605; box-shadow: 2px 2px 2px rgba(0, 0, 0, .2);&#125;.box::after &#123; content: ''; position: absolute; bottom: -9px; left: 45px; border-left: 10px solid transparent; border-right: 10px solid transparent; border-top: 10px solid #ff8605;&#125; 缺点很明显, 我们不能通过box-shadow的方式来设置阴影, 阴影会是一个盒子 但如果不用设阴影, 只是需要边框的话, 我们可以再定义一个伪类元素, 覆盖到三角形的下面即可123456789.box::before &#123; position: absolute; bottom: -10px; left: 45px; content: ''; border-left: 10px solid transparent; border-right: 10px solid transparent; border-top: 10px solid rgba(0, 0, 0, .1);&#125; 如图所示 如果要求不严格似乎也够用了. 但作为一个严峻的前端工程师! 我们还是不能容忍这种实现方法, 下面我们看一看tranform方法是如何解决的 2.2 transform方法这种方法的思路就是使用transform旋转盒子, 一半被上面的容器遮挡, 一半显示出来 1234567891011.box::before &#123; position: absolute; bottom: -5px; left: 45px; content: ''; width: 10px; height: 10px; background: #ff8605; transform: rotate(135deg); box-shadow: 1px -2px 2px rgba(0, 0, 0, .2);&#125; 我们似乎实现了我们想要的结果, 但是, 其实是存在一个问题的, 但因为我们的阴影面积不够大, 所以图片上看起来不明显 当我们把box-shadow的阴影面积扩大时, 我们发现到问题的所在了 盒子突出来了, 那怎么解决呢 我们再定义一个与容器颜色相同的盒子, 将上半部分盖住就可以啦.123456789101112131415161718192021/* transform方法 */.box::before &#123; position: absolute; bottom: -5px; left: 45px; content: ''; width: 10px; height: 10px; background: #ff8605; transform: rotate(135deg); box-shadow: 1px -2px 5px rgba(0, 0, 0, .2);&#125;.box::after &#123; position: absolute; bottom: 0px; left: 40px; content: ''; width: 20px; height: 20px; background: #ff8605;&#125; 要注意三角形应该用before定义, 覆盖的盒子应该用after定义, 这样盒子才能覆盖到三角形上面 实现效果: 3. 最终解决方案代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width\" /&gt; &lt;title&gt;CSS实现带阴影效果的三角形&lt;/title&gt; &lt;style&gt; .box &#123; position: relative; width: 200px; height: 100px; background: #ff8605; box-shadow: 2px 2px 2px rgba(0, 0, 0, .2); &#125; .box::before &#123; position: absolute; bottom: -5px; left: 45px; content: ''; width: 10px; height: 10px; background: #ff8605; transform: rotate(135deg); box-shadow: 1px -2px 5px rgba(0, 0, 0, .2); &#125; .box::after &#123; position: absolute; bottom: 0px; left: 40px; content: ''; width: 20px; height: 20px; background: #ff8605; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如果你有更好的实现办法, 欢迎给我留言","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[]},{"title":"写给自己看的React 笔记","slug":"写给自己看的React-笔记","date":"2019-03-02T08:27:59.000Z","updated":"2019-03-04T09:57:13.607Z","comments":true,"path":"2019/03/02/写给自己看的React-笔记/","link":"","permalink":"http://yoursite.com/2019/03/02/写给自己看的React-笔记/","excerpt":"","text":"写给自己看的React 笔记 1. JSX 介绍JSX 事实上是 JavaScript 语法的扩展 在JSX中可以写各种js表达式(变量, 函数, 运算等), 用大括号包起来12345678910class App extends Component &#123; render() &#123; const t = \"哈利波特\" return ( &lt;div className=\"App\"&gt; &#123; t &#125; &lt;/div&gt; ); &#125;&#125; JSX 通过 Babel编译和React.js构造成 JavaScript对象结构, 再从 JavaScript对象 渲染成 DOM元素 例如:12345const element = ( &lt;h1 className=\"greeting\"&gt; Hello, world! &lt;/h1&gt;); Babel 转译器会把 JSX 转换成一个名为React.createElement() 的方法调用。 将被描述为123456// 伪代码const element = React.createElement( type: 'h1', className: 'greeting', content: 'Hello, world!'); React再将js对象转化为DOM元素 2. 组件和propsprops是React组件的输入, 它是从父组件向下传递给子组件的数据 看一个例子.12345678const Welcome = function(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;ReactDOM.render( &lt;Welcome name=\"zmj\" /&gt;, document.getElementById('root')); 这个例子中发生了四个步骤 我们通过ReactDOM.render()方法渲染了&lt;Welcome name=&quot;zmj&quot; /&gt;组件 React 将 {name: ‘zmj’} 作为props传入Welcome组件 Welcome组件将&lt;h1&gt;Hello, zmj&lt;/h1&gt;元素作为结果返回。 React DOM将DOM更新 注意: props是只读的, 不能修改它 补充一个属性props.childrenprops.children在每个组件上都可用。 它会包含组件的开始和结束标记之间的内容 12345678// 伪代码class Welcome extends React.Component &#123; render() &#123; return &lt;p&gt;&#123;this.props.children&#125;&lt;/p&gt;; &#125;&#125;&lt;Welcome&gt;Hello world!&lt;/Welcome&gt; 这里的this.props.children就是Hello, wolrd 其实也就等同于1&lt;Welcome children=\"Hello world\"&gt;&lt;/Welcome&gt; 3. state 和 生命周期state和props很相似, 但state是私有的, 受控于当前组件 生命周期 3.1 一个例子12345678910111213141516171819202122232425262728293031class Clock extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; data: new Date() &#125; &#125; componentDidMount() &#123; this.timerID = setInterval(this.tick.bind(this), 1000) &#125; componentWillMount() &#123; clearInterval(this.timerID) &#125; tick() &#123; this.setState(&#123; data: new Date() &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;时钟的时间如下:&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.data.toLocaleTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Clock /&gt;, document.getElementById('root')) 构造函数中super是必须的, super()代表调用父类的构造函数(React.Component) 这个例子的经历的流程 当 &lt;Clock /&gt; 被传递给 ReactDOM.render() 时，React 调用 Clock 组件的构造函数. 初始化了this.state React 调用 render()方法. 当 Clock 的输出插入到 DOM 中时, React 调用 componentDidMount() 生命周期钩子, Clock 组件要求浏览器设置一个定时器，每秒钟调用一次 tick(). 调用tick(), 通过使用setState来调度UI更新. 一旦Clock组件从DOM中被移除, React会调用componentWillUnmount()这个钩子函数, 定时器被清除 3.2 正确的使用状态关于setState()有三件事很重要 3.2.1 不要直接更新状态12// wrongthis.state.comment = 'hello' 应该使用setState()更新, 只有构造函数中是唯一能够初始化state的地方 3.2.2 setState()可能是异步的React 可以将多个setState() 调用合并成一个调用来提高性能。 因为 this.props 和 this.state 可能是异步更新的，你不应该依靠它们的值来计算下一个状态。123456789// Wrongthis.setState(&#123; counter: this.state.counter + this.props.increment,&#125;);// correctthis.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;)); 3.2.3 状态更新合并当你调用 setState() 时，React 将你提供的对象合并到当前状态。 意思就是如果state保存了多个键值对.1234this.state = &#123; posts: [], comments: []&#125; 可以单独更新一个值, React会自动合并到当前状态123this.setState(&#123; comments: ['hello']&#125;) 4. 列表 &amp; keys在渲染一段列表元素的时候, 最好使用map方法123456789101112render() &#123; return ( &lt;div&gt; &lt;h1&gt;渲染列表&lt;/h1&gt; &lt;ul&gt; &#123;[1, 2, 3, 4, 5].map(val =&gt; &#123; return &lt;li&gt;&#123;val&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; &lt;/div&gt; )&#125; 控制窗会弹出警告Each child in a list should have a unique &quot;key&quot; prop.意思是当你创建一个元素的时候, 必须包含一个唯一的key值 这里临时用数组的下标当了key值, 不推荐这样做, key值必须是唯一的123&#123;[1, 2, 3, 4, 5].map((val, index) =&gt; &#123; return &lt;li key=&#123;index&#125;&gt;&#123;val&#125;&lt;/li&gt;&#125;)&#125; 为什么要给列表元素加上key值并且要唯一呢? 这就要了解到React的渲染策略. diff算法 首先看一个例子我们将列表集合[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]更新成[&#39;B&#39;, &#39;A&#39;, &#39;D&#39;, &#39;C&#39;]如果你不加key, 更新的办法是逐个比较差异 B != A, 于是 B 节点被重新创建渲染 A != B, 于是 A 节点被重新创建渲染 D != C, 于是 C 节点被重新创建渲染 C != D, 于是 D 节点被重新创建渲染 可是我们的节点仅仅是交换了位置, 结果却被全部重新创建渲染了一遍, 大大影响了性能. React给出的解决方案是给集合元素加上key 如图所示: 我们给每个节点加上了唯一的key. React通过key发现, 新老集合中的节点都是相同的, 于是只进行了移动操作, 得到了新的集合, 大大提高了性能. 总言之, 给元素加上唯一的key利于React的性能提升, 这是一件必须得事情.","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[]},{"title":"浅析React中的虚拟DOM和diff算法","slug":"React中的虚拟DOM和diff算法","date":"2019-03-02T07:38:37.000Z","updated":"2019-03-02T07:39:12.249Z","comments":true,"path":"2019/03/02/React中的虚拟DOM和diff算法/","link":"","permalink":"http://yoursite.com/2019/03/02/React中的虚拟DOM和diff算法/","excerpt":"","text":"虚拟DOMReact原理 我们来想一下如何实现React 第一种方案：123451. state 数据2. JSX 模板3. 数据 + 模板 结合, 生成真实的DOM, 来显示4. state 发生改变5. 数据 + 模板 结合, 生成真实的DOM, 替换原始的DOM 但这种方案在第五步有着很大的性能缺陷用新生成的DOM去替换原始的DOM, 非常消耗性能 第二种方案123456781. state 数据2. JSX 模板3. 数据 + 模板 结合, 生成真实的DOM, 来显示4. state 发生改变5. 数据 + 模板 结合, 生成真实的DOM, 并不直接替换原始的DOM6. 新的DOM (DocumentFragment) 和原始的DOM 做比对，找差异7. 找出有差异的DOM元素8. 将有差异的DOM元素替换掉旧的DOM元素 这种方案同样存在缺陷关键在于第六步，我们找新DOM和原始DOM的比对找差异过程中，也很消耗性能，性能提升并不明显 第三种方案：虚拟DOM 123456789101112131415161718191. state 数据2. JSX 模板3. 生成虚拟DOM(JS对象), 用js对象描述dom信息 &#123; tag: 'div', attrs: &#123;id: 'root'&#125;, children: [ &#123; tag: 'p', children: ['hello, world'] &#125; ] &#125;4. 借助虚拟DOM, 生成真实的DOM, 来显示 &lt;div id='root'&gt;&lt;p&gt;hello, world&lt;/p&gt;&lt;/div&gt;5. state 发生改变6. 生成新的虚拟DOM7. 比较原始虚拟DOM和新的虚拟DOM的差异8. 直接操作DOM，改变有差异的内容 优点：生成 js 对象很快, 所以在两个js对象中找差异 损耗性能很小极大的提升了性能 diff算法diff算法用于比较虚拟dom之间的差异 1. 逐级比较diff算法通过逐级的去比较两颗节点树的差异，大大降低了复杂性 2. 列表List假设我们有一个组件，它在一个迭代中渲染了5个组件，而下一次渲染的时候在组件列表的中间插入一个新的组件。 只是通过这个信息真的很难知道如何在两个组件列表之间进行映射。默认情况下，React将先前列表的第一个组件与下一个列表的第一个组件相关联，等等。您可以提供一个Key属性，以帮助React去找到他们的映射关系。 在实际中，这通常很容易把刚刚插入的组件从他们当中找出来。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"虚拟DOM","slug":"虚拟DOM","permalink":"http://yoursite.com/tags/虚拟DOM/"},{"name":"diff","slug":"diff","permalink":"http://yoursite.com/tags/diff/"}]},{"title":"从ES5的角度看ES6中的class","slug":"从ES5的角度看ES6中的class","date":"2019-03-02T07:37:16.000Z","updated":"2019-03-02T07:38:08.002Z","comments":true,"path":"2019/03/02/从ES5的角度看ES6中的class/","link":"","permalink":"http://yoursite.com/2019/03/02/从ES5的角度看ES6中的class/","excerpt":"","text":"前言ES6的 class 是语法糖, 相当好用, 主要介绍几个关键的概念 仿类结构 类的声明 静态成员 类的继承 1. ES5 中的仿类结构在ES6之前没有class语法, 我们仿写一个类结构12345678910var Person = function() &#123; this.name = name&#125;Person.prototype.sayName = function() &#123; console.log(this.name)&#125;var p = new Person('zmj')p.sayName() Person是一个构造函数, sayName()方法被指派到原型上, 因此Person的所有实例都共享了sayName方法 2. ES6 类的声明将上例改写成类12345678910111213class Person &#123; // 相当于 Person 的构造函数, 私有属性应该写在这里 constructor(name) &#123; this.name = name &#125; // 相当于Person.prototype.sayName sayName() &#123; console.log(this.name) &#125;&#125;var p = new Person('zmj')p.sayName() 与ES5写法的区别: 类声明不会被提升, 与 let 相似 所有代码都处于严格模式 不可枚举 其实上面的类结构等价于下面的代码1234567891011121314151617181920let Person = (function () &#123; \"use strict\" const Person = function(name) &#123; this.name = name &#125; Object.defineProperty(Person.prototype, 'sayName', &#123; value: function() &#123; console.log(this.name) &#125;, enumerable: false, writable: true, configurable: true &#125;) return Person&#125;)()var p = new Person('zmj')p.sayName() 3. 静态成员首先要理解静态成员的含义. 静态成员是类所有的, 不需要创建实例就可以调用(通过类名直接调用) 在ES5中的例子1234567891011121314var Person = function(name) &#123; this.name = name&#125;Person.create = function(name) &#123; return new Person(name)&#125;Person.prototype.sayName = function() &#123; console.log(this.name)&#125;var p = Person.create('zmj')p.sayName() Person.create就是所谓的静态方法. 它的数据不依赖任何类的实例 可以直接通过类名.方法名直接调用, 不需要new一个新的实例 在ES6中简化了该操作, 只要在方法名上加上static即可.12345class Person() &#123; static create(name) &#123; return new Person(name) &#125;&#125; 4. 继承在ES5中, 实现继承是一个很麻烦的事情. 实现一个继承, 父类是一个矩形类, 子类是正方形类123456789101112131415161718192021222324function Reactangle(length, width) &#123; this.length = length this.width = width&#125;Reactangle.prototype.getArea = function() &#123; return this.length * this.width&#125;function Square(length) &#123; Reactangle.call(this, length, length)&#125;Square.prototype = Object.create(Reactangle.prototype, &#123; constructor: &#123; value: Square, enumerable: true, writable: true, configurable: true &#125;&#125;)var square = new Square(3)square.getArea() 必须用Object.create 关联子类和父类的原型, 并且在子类的构造方法中还要使用Reactangle.call()方法 用ES6重写12345678910111213141516171819class Rectangle &#123; constructor(length, width) &#123; this.length = length this.width = width &#125; getArea() &#123; return this.length * this.width &#125;&#125;class Square extends Rectangle &#123; constructor(length) &#123; // 与 Rectangle.call(this, length, length) 相同 super(length, length) &#125;&#125;var square = new Square(3)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"实现左侧固定宽度, 右侧自适应的两栏布局常见方法","slug":"实现左侧固定宽度-右侧自适应的两栏布局常见方法","date":"2019-02-27T05:22:08.000Z","updated":"2019-02-27T05:22:52.893Z","comments":true,"path":"2019/02/27/实现左侧固定宽度-右侧自适应的两栏布局常见方法/","link":"","permalink":"http://yoursite.com/2019/02/27/实现左侧固定宽度-右侧自适应的两栏布局常见方法/","excerpt":"","text":"两栏布局方案实现左侧固定, 右侧自适应的布局方案, 常见的几种, 写了一个各个方案实现效果的Demo, 可以通过这里查看: 预览 首先统一html结构12345678&lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt; &lt;p&gt;这是左边的盒子&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;p&gt;这是右边的盒子&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 然后统一样式, 左侧固定宽度12345678910111213.container &#123; padding: 10px; border: 1px dashed #dedede;&#125;.left &#123; width: 120px; border: 2px solid #2DB3E4;&#125;.right &#123; border: 2px solid #F37EC1;&#125; 1. 双float方案利用CSS的calc()函数来计算右侧宽度值, 需要清除父容器的浮动 设置box-sizing: border-box;是为了方便计算1234567891011121314.container::after &#123; content: \"\"; display: block; clear: both;&#125;.left, .right &#123; box-sizing: border-box; float: left;&#125;.right &#123; width: calc(100% - 120px);&#125; 2. float + margin-left方案block的元素盒子的宽度具有填满父容器，并随着父容器的宽度自适应的流动特性。 并且 block元素和浮动元素并排时, block元素会忽视浮动元素 因此给左侧盒子浮动, 右侧设置margin-left保持距离即可1234567891011121314.container::after &#123; content: \"\"; display: block; clear: both;&#125;.left &#123; box-sizing: border-box; float: left;&#125;.right &#123; margin-left: 120px;&#125; 3. absolute + margin-left与方案2原理大致相同, absolute也是会脱离文档流 不用清除浮动, 但也带来了新的问题 父容器需要改变position 如果左侧盒子比右侧盒子高度, 那么左侧盒子会超出父容器高度 12345678.left &#123; box-sizing: border-box; position: absolute;&#125;.right &#123; margin-left: 120px;&#125; 4. float + BFC 方法这种方法不用计算宽度,原理是BFC可以阻止元素被浮动元素覆盖1234567891011121314.container::after &#123; content: \"\"; display: block; clear: both;&#125;.left &#123; float: left;&#125;.right &#123; margin-left: 0; overflow: auto;&#125; 父容器需要清除浮动, 右侧盒子设置了overflow: auto;形成了BFC 5. flex方案flex可以说是最好的方案了 直接给右侧盒子设置flex: 1, 即可自动填满宽度 1234567.container &#123; display: flex;&#125;.right &#123; flex: 1&#125;","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"布局","slug":"布局","permalink":"http://yoursite.com/tags/布局/"}]},{"title":"puppeteer 安装踩坑记","slug":"puppeteer-安装踩坑记","date":"2019-02-22T09:22:26.000Z","updated":"2019-02-22T09:37:22.094Z","comments":true,"path":"2019/02/22/puppeteer-安装踩坑记/","link":"","permalink":"http://yoursite.com/2019/02/22/puppeteer-安装踩坑记/","excerpt":"","text":"Puppeteerpuppeteer是chrome官方开发的Node库 可以模拟浏览器操作 1. 安装安装的时候遇到了问题 在执行下面这条安装命令的时候, 发现安装很长时间都成功不了1yarn add puppeteer 原因是: 安装puppeteer的时候, 它会下载最新的Chromium(需要翻墙才能下) 因此国内下载基本是下不了的 2. 解决方案2.1 跳过Chromium下载官方给个解决方案是设置环境变量1PUPPETEER_SKIP_CHROMIUM_DOWNLOAD - do not download bundled Chromium during installation step. 因此我们只要把PUPPETEER_SKIP_CHROMIUM_DOWNLOAD 这个环境变量设为true 即可 运行下面的命令能成功安装puppetter1env PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true yarn add puppeteer 2.2 下载Chromium还是要下载Chromium才能运行puppeteer因此到淘宝的源里下载 1https://npm.taobao.org/mirrors/chromium-browser-snapshots/ 值得一提是选择版本的问题, 该下载哪个Chromium版本? 此时只要打开项目中node_modules下的puppeteer包的package.json就能知道依赖的Chromium版本了 我的版本是123\"puppeteer\": &#123; \"chromium_revision\": \"624492\"&#125;, 3. 运行puppteer Demo指定Chromium路径下的chrome.exe, 在launch方法中添加路径即可 12345678910111213const puppeteer = require('puppeteer')const &#123; resolve &#125; = require('path')(async () =&gt; &#123; const path = resolve(__dirname, '../../chrome-win/chrome.exe') const browser = await puppeteer.launch(&#123; executablePath: path &#125;) const page = await browser.newPage() await page.goto('https://www.baidu.com') await page.screenshot(&#123;path: 'baidu.png'&#125;) await browser.close()&#125;)()","categories":[{"name":"node","slug":"node","permalink":"http://yoursite.com/categories/node/"}],"tags":[{"name":"bug","slug":"bug","permalink":"http://yoursite.com/tags/bug/"},{"name":"puppeteer","slug":"puppeteer","permalink":"http://yoursite.com/tags/puppeteer/"}]},{"title":"CSS 清除浮动原理详解","slug":"CSS-清除浮动原理详解","date":"2019-02-18T01:34:23.000Z","updated":"2019-02-18T01:34:48.980Z","comments":true,"path":"2019/02/18/CSS-清除浮动原理详解/","link":"","permalink":"http://yoursite.com/2019/02/18/CSS-清除浮动原理详解/","excerpt":"","text":"CSS 清除浮动原理详解一. 浮动floatfloat属性的本质是用来实现文字环绕效果的。它有一个很大的副作用：会导致父容器的高度坍塌 疑问： 那么将父容器固定高度有用吗？没用，因为只要浮动元素的区域超过了这个高度，依旧会出现环绕效果影响布局 那么怎么解决这个问题呢？清除浮动方法很多，但本质上只有两种方法 使用clear清除浮动 形成BFC 1.1 使用clear清除浮动clear 属性是 CSS 专门用来处理 float引起的高度坍塌问题 语法： clear: none | left | right | both 使用clear: both就可以, left和right可以完全被替代 使用clear要注意的地方 clear只会清除自身所在前面的元素的浮动 clear属性只作用在块级元素上 因为clear只会清除前面元素的浮动，因此我们要在容器的最后面添加一个块级元素，并让该元素使用clear: both属性 最常见的做法就是在父容器身上使用::after12345#container::after &#123; content: \"\"; display: block; clear: both;&#125; 因为clear只作用在块级元素上, ::after等伪元素都是内联的所以我们要加上这两行12content: \"\";display: block; 1.2 使用BFC清除浮动BFC全称为 block formatting context, 中文为”块级格式化上下文” 性质：如果一个元素触发了 BFC , 那么该元素会形成一个独立容器, 不会影响到外界元素只要触发了 BFC , 元素就不会因为 float 引起高度坍塌 如何触发BFC以下规则只要满足任意一条，即可触发 根元素 float 的值不为 none overflow 的值为 auto、scroll 或 hidden display 的值为 table-cell、table-caption 和 inline-block 中的任何一个 position 的值不为 relative 和 static BFC的一些特性 计算BFC高度时，浮动元素也会参与计算(用来解决父元素高度塌陷问题） 是一个独立的容器，外面元素不会影响他里面的元素 BFC元素不会与浮动元素的盒子相互重叠（解决兄弟元素排版混乱问题）","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"float","slug":"float","permalink":"http://yoursite.com/tags/float/"}]},{"title":"JavaScript 模拟实现call和apply","slug":"JavaScript-模拟实现call和apply","date":"2019-01-27T12:51:24.000Z","updated":"2019-01-27T13:13:14.847Z","comments":true,"path":"2019/01/27/JavaScript-模拟实现call和apply/","link":"","permalink":"http://yoursite.com/2019/01/27/JavaScript-模拟实现call和apply/","excerpt":"","text":"1. call和apply区别 简单概论：call 调用一个函数，并指定函数的this和参数列表apply 调用一个函数，并指定函数的this和参数数组 call和apply的区别就是 一个接收参数列表，一个接收参数数组 2. 分析由于两者区别不大，所以我们用call分析 例子123456789var obj = &#123; name: 'zmj'&#125;function sayName() &#123; console.log(this.name)&#125;sayName.call(foo) // 'zmj' 这个例子中可以看出call做了两件事 call改变了this的指向，指向了 foo bar函数执行 所以我们模拟实现的思路大致分为三步： 把函数设为对象的属性 执行该函数 删除该函数 3. call实现首先写出call的最简单版本12345Function.prototype.call = function(context) &#123; context.fn = this context.fn() delete context.fn&#125; 但我们还有情况没有考虑 call的第一个参数可以为null call可以给传参数 函数返回值 因此继续优化12345678910111213Function.prototype.callES3 = function(context) &#123; context = context || window context.fn = this var args = [] for (var i = 1; i &lt; arguments.length; i++) &#123; args.push('arguments[' + i + ']') &#125; var res = eval('context.fn(' + args + ')') delete context.fn return res&#125; 因为call后面的参数是不固定的，所以我们只能用arguments来获取 然后我们除去第一个参数，将剩余的参数保存到args数组中, 将参数拼接, 使用eval方法执行然后接收返回值 使用ES6的扩展表达式能把实现写的更漂亮简洁些12345678910Function.prototype.callES6 = function(context) &#123; context = context || window context.fn = this let args = [...arguments].slice(1) let res = context.fn(...args) delete context.fn return res&#125; 4. apply实现apply实现原理与call相同 这里给出apply实现 12345678910111213141516171819202122232425262728293031// apply ES3实现Function.prototype.applyES3 = function(context, arr) &#123; context = context || window context.fn = this var res if (arr) &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')'); &#125; else &#123; res = context.fn() &#125; return res&#125;// apply ES6实现Function.prototype.applyES6 = function(context, arr) &#123; context = context || window context.fn = this let res if (arr) &#123; res = context.fn(...arr) &#125; else &#123; res = context.fn() &#125; delete context.fn return res&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"call","slug":"call","permalink":"http://yoursite.com/tags/call/"},{"name":"apply","slug":"apply","permalink":"http://yoursite.com/tags/apply/"}]},{"title":"使用python爬取 ycxy-3000张证件照","slug":"使用python爬取-ycxy-3000张证件照","date":"2019-01-24T13:51:55.000Z","updated":"2019-02-18T04:01:47.973Z","comments":true,"path":"2019/01/24/使用python爬取-ycxy-3000张证件照/","link":"","permalink":"http://yoursite.com/2019/01/24/使用python爬取-ycxy-3000张证件照/","excerpt":"","text":"使用python爬取 ycxy-3000张证件照1. 前言之前在查普通话成绩的时候，发现需要只名字和身份证就能查到用户的的证件照 在学校的网站上，学生信息经常会被公开，比如四六级考试，或者防护性做的比较差的教务管理系统，很容易就能拿到同学的信息，于是我用爬虫爬拿到了学校一部分同学的证件照 2. 环境准备 chrome python 3 requests 网络库 os 本地存储 urllib.request 下载图片 json 临时存储数据 time 计算爬虫时间普通话成绩查询网址：http://www.cltt.org/studentscore3. 分析 打开F12开发者工具，观察到我们的表单数据通过post方式，提交给了/StudentScore/ScoreResult 打开开发者工具的NetWork选项，我们模拟一次发送数据 找到了ScoreResult我们看到post请求提交了三个数据name, stuID, idCard于是我们就可以使用requests 来模拟发送post请求了 然后分析html结构，发现图片在类名为user-img的span标签的子结点下 4. 代码4.1 爬取照片地址首先，我已经通过爬虫拿到了学生的信息并保存到了本地所以直接从本地读取json得到学生对象1234def get_stu_list(path): with open(path, 'r', encoding='utf-8') as f: stu_list = json.load(f) return stu_list 然后请求网站得到照片的地址，做了一些异常处理，因为有些同学可能没有去参加这个考试~ 123456789101112131415161718192021222324def get_image_url(name, id): if not name or not id: return \"\" url = 'http://www.cltt.org/StudentScore/ScoreResult' headers = &#123; \"User-Agent\": 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/71.0.3578.98 Safari/537.36' &#125; data = &#123; 'name': name, 'idCard': id &#125; try: res = requests.post(url, data=data, headers=headers).text except requests.ConnectionError: print(name + '查询异常') return \"\" doc = PyQuery(res) img_src = doc('.user-img').find('img').attr('src') if not img_src: return \"\" else: return img_src 然后通过学生数组，循环调用get_image_url，我们就可以拿到所有的照片地址 4.2 给图片分类保存到本地拿到照片地址之后，我们使用urlretrieve方法来下载图片 使用os.markdirs方法来创建文件夹并给图片分类 1234567891011121314def get_stu_list(path): with open(path, 'r', encoding='utf-8') as f: stu_list = json.load(f) for stu in stu_list: if not stu['img']: continue college = stu['college'] stu_class = stu['class'] directory = college + '/' + stu_class if not os.path.exists(directory): os.makedirs(directory) filename = '&#123;&#125;/&#123;&#125;/&#123;&#125;.jpeg'.format(college, stu_class, stu['name']) urlretrieve(stu['img'], filename=filename) return stu_list 5. 总结图片分两级目录，第一级是学院，第二级是班级学院目录： 班级目录： 其中一个班级： 爬取3164张照片一共花费了约20分钟 github：https://github.com/zzzmj/photo-crawler撒花，感谢你的观看，点个Star吧，Thanks♪(･ω･)ﾉ","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"}]},{"title":"欧拉函数及其计算","slug":"欧拉函数及其计算","date":"2019-01-22T13:11:29.000Z","updated":"2019-01-22T13:11:44.633Z","comments":true,"path":"2019/01/22/欧拉函数及其计算/","link":"","permalink":"http://yoursite.com/2019/01/22/欧拉函数及其计算/","excerpt":"","text":"欧拉函数1. 定义什么是欧拉函数？ 任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？） 计算这个值的方法就叫做欧拉函数，用φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。 2. 计算欧拉函数计算公式这个p是什么呢？ 一个正整数 n 可以通过分解质因数得到例如n = 100我们就可以写成 100 = 2^2 + 5^2 欧拉值 φ(n) = 100 * (1- 1/2) * (1 - 1/5) 那么知道了这个公式，我们怎么去计算呢 大致的几步找到因子将把(1- 1/p)转换为(p - 1) / p然后把相同的因子筛去 12345678910111213141516int euler(int n) &#123; int ans = n; for (int i = 2; i*i &lt;= ans; i++) &#123; if (n % i == 0) &#123; ans = ans / i * (i-1); // 将相同的因子除去 while (n % i == 0) &#123; n /= i; &#125; &#125; &#125; if (n &gt; 1) &#123; ans = ans / n * (n-1); &#125; return ans;&#125; 由于本文主要目的是讲如何计算，欧拉函数公式的推导过程可以参考维基百科：欧拉函数","categories":[],"tags":[]},{"title":"JS中typeof和instanceof的区别","slug":"JS中typeof和instanceof的区别","date":"2019-01-10T09:00:09.000Z","updated":"2019-01-10T09:00:32.102Z","comments":true,"path":"2019/01/10/JS中typeof和instanceof的区别/","link":"","permalink":"http://yoursite.com/2019/01/10/JS中typeof和instanceof的区别/","excerpt":"","text":"区别：typeof运算符用来检测基本数据类型使用方法：typeof opera或者typeof(operand) instanceof运算符用来检测对象类型（引用类型）准确些可以说：来判断某个对象是否是某个类的一个实例是则返回true，否则返回false使用方法：variable instanceof constructor 1. 基本数据类型typeof用来检测五种基本数据类型 string number boolean null undefined typeof检测null会返回object，这是语言本身的一个bug，因为null本身属于基本类型 一般不推荐使用typeof来检测引用类型 检测函数对象时会返回function其他对象时均返回object 2. 内置对象常见的内置对象 String Number Boolean Object Function Array Date RegExp 如果变量是给定引用类型的实例，那么instanceof操作符就会返回true 1234var a = []a instanceof Array // 变量a是Array类型吗?var b = &#123;&#125;b instanceof Object // 变量b是Object类型吗? 如果使用instanceof检测基本类型，那么操作符始终返回false，因为基本类型不是对象1234var a = 1var b = 'zmj'a instanceof Number // falseb instanceof String // false 参考资料：你不知道的JavaScript(上卷) JavaScript高级程序设计（第3版） typeof | MDN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"JavaScript函数中this的四种绑定策略","slug":"JavaScript函数中this的四种绑定策略","date":"2019-01-01T06:44:36.000Z","updated":"2019-01-01T10:03:24.796Z","comments":true,"path":"2019/01/01/JavaScript函数中this的四种绑定策略/","link":"","permalink":"http://yoursite.com/2019/01/01/JavaScript函数中this的四种绑定策略/","excerpt":"","text":"this的四种绑定策略 默认绑定 隐式绑定 显示绑定 new绑定 1. 默认绑定当一个函数没有明确的调用对象的时候，也就是单纯作为独立函数调用的时候，将对函数的this使用默认绑定：绑定到全局的window对象 123456// 第一个例子var foo = function() &#123; console.log(this.a);&#125;var a = 2foo() // 2 12345678910// 第二个迷惑性的例子var foo = function() &#123; var a = 3 var inner = function() &#123; console.log(this.a); &#125; inner()&#125;var a = 2foo() // 2 第二个例子虽然在foo()作用域内声明了a变量为3, 但它并不是一个对象, 所以this最终还是会指向全局的window对象 2. 隐式绑定函数被调用时有上下文对象，那么this会绑定这个上下文对象 书上写的上下文对象意思很模糊, 觉得这里翻译的其实不太好 我感觉比较好的解释是：当函数被一个对象包含的时候, 我们称这个函数的this被隐式绑定到这个对象上了 123456var o = &#123; a: 2, foo: function() &#123; console.log(this.a); &#125;,&#125; 在一串对象属性引用链中, this绑定的是最内层的对象 12345678910111213var obj = &#123; a: 1, obj2: &#123; a: 2, obj3: &#123; a:3, getA: function () &#123; console.log(this.a) &#125; &#125; &#125;&#125;obj.obj2.obj3.getA(); // 输出3 隐式丢失最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象, 也就是它会应用默认绑定, 把this绑定到全局对象或者undefined上 12345678910var foo = function() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo,&#125;var a = 5var bar = obj.foo bar() // 5 像这个例子, obj对象把foo函数的引用传给bar的时候, 会丢失this对obj的绑定 回调函数同样也会丢失绑定123456789var foo = function() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo,&#125;var a = 5setTimeout(obj.foo, 100) // 5 这种函数赋值的方式是无法将函数所绑定的this对象也传递过去的 3. 显式绑定显式绑定是通过apply或者call函数绑定的对象 如果你想传递函数并且把所绑定的this对象也传递过去, 那么就可以使用call() fn.call(object) fn是你调用的函数 object是你希望绑定的对象 作用：即刻调用函数fn(), 调用时这个函数的this指向object 12345678var foo = function() &#123; console.log(this.a)&#125;var obj = &#123; a: 1,&#125;foo.call(obj) 这样做有个缺点, 每次调用都会依赖call 所以可以将它包装成函数12345678910var foo = function() &#123; console.log(this.a)&#125;var obj = &#123; a: 1,&#125;var bar = function() &#123; foo.call(obj)&#125;bar() 如果使用bind会更简单12345678var foo = function() &#123; console.log(this.a)&#125;var obj = &#123; a: 1,&#125;var bar = foo.bind(obj)bar() call和bind的区别是：在绑定this到对象参数的同时： call将立即执行该函数 bind不执行函数，只返回一个可供执行的函数 4. new绑定来new来调用函数，会自动执行下列操作 创建一个全新的对象 这个新对象被执行[[prototype]]连接 这个新对象会绑定到函数调用的this 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象 123456function foo(a) &#123; this.a = a;&#125;var bar = new foo(2)console.log(bar.a) // 2 5. 优先级new绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 默认绑定在严格模式下会绑定到undefined, 否则绑定到全局对象 参考资料：你不知道的JavaScript(上卷)【javascript】函数中的this的四种绑定形式","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"this","slug":"this","permalink":"http://yoursite.com/tags/this/"},{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/函数/"}]},{"title":"for 循环中的setTimeout(function(){})异步问题","slug":"for-循环中的setTimeout-function-异步问题","date":"2018-12-20T11:12:44.000Z","updated":"2018-12-26T00:58:49.552Z","comments":true,"path":"2018/12/20/for-循环中的setTimeout-function-异步问题/","link":"","permalink":"http://yoursite.com/2018/12/20/for-循环中的setTimeout-function-异步问题/","excerpt":"","text":"阅读这段代码 12345for (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000)&#125; 预期是分别输出数字1-5, 每秒1次，每次1个结果却是每秒一次输出了5个6 setTimeout的执行原理setTimeout()是一个异步方法, 传递一个函数，延迟一段时候把该函数添加到队列当中，并不是立即执行,而且必须等当前环境所有代码执行完以后, 才会运行 也就是说我们执行这个for循环的时候12345setTimeout(fun(...), 1000)setTimeout(fun(...), 2000)setTimeout(fun(...), 3000)setTimeout(fun(...), 4000)setTimeout(fun(...), 5000) 五个函数先进入了队列, 然后等for循环结束后再依次出队 (粗略理解, 实质上是回调函数)for循环结束后, 此时i是等于6的, 所以每秒一次输出了5个6 要注意到var定义的i实质上是全局变量, 等同于下面的代码1234var ifor (i = 1; i &lt;= 5; i++) &#123; ...&#125; 解决办法使用闭包这个办法的原理是创建了闭包作用域, 每次循环会生成一个新的闭包作用域, 使得延迟函数回调可以访问到正确的值 注意, 闭包作用域里必须声明变量j, 如果是一个空的作用域, 那不会产生作用1234567for (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;, j*1000) &#125;)(i)&#125; 使用ES6中的let这个办法的原理是通过let来劫持块作用域, 注意, 这个变量i不只会声明一次, 每次迭代的时候都会声明i, 每次迭代后, i的值都会使用 上一个迭代的值来初始化这个变量, 形成一个块作用域 12345for (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000)&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/异步/"},{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/闭包/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"使用python 原生socket搭建简单服务器","slug":"使用python-原生socket搭建简单服务器","date":"2018-12-07T08:37:19.000Z","updated":"2018-12-07T08:47:39.514Z","comments":true,"path":"2018/12/07/使用python-原生socket搭建简单服务器/","link":"","permalink":"http://yoursite.com/2018/12/07/使用python-原生socket搭建简单服务器/","excerpt":"","text":"使用socket搭建简单的服务器socket通信流程 chrome浏览器模拟客户端, 访问该服务器, 显示文字和图片 其中值得注意的地方: 当我键入服务器地址访问时, chrome浏览器给服务器发送了四个http请求 请求1: 请求主页 GET / HTTP/1.1Host: localhost:3000 请求2: 请求图片 GET /doge.gif HTTP/1.1Host: localhost:3000 请求3：请求标签栏图标 GET /favicon.ico HTTP/1.1Host: localhost:3000 请求4：空请求 会导致程序报错, 需要捕获这个请求，因为会我写的responce_for_pat里没有响应空请求 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import socketdef route_index(): \"\"\" 主页的处理函数, 返回主页的响应 \"\"\" header = 'HTTP/1.x 200 OK\\r\\nContent-Type: text/html\\r\\n' body = '&lt;h1&gt;Hello World&lt;/h1&gt;&lt;img src=\"doge.gif\"/&gt;' r = header + '\\r\\n' + body return r.encode(encoding='utf-8')def route_img(): \"\"\" 图片的处理函数, 读取图片并生成响应返回 \"\"\" with open('doge.gif', 'rb') as f: header = b'HTTP/1.x 200 OK\\r\\nContent-Type: image/gif\\r\\n\\r\\n' img = header + f.read() return imgdef responce_for_path(path): \"\"\" 根据 path 调用相应的处理函数 没有处理的 path 会返回 404 \"\"\" r = &#123; '/': route_index, '/doge.gif': route_img, &#125; # 这里得到的是一个函数体 responce = r.get(path) return responce()def run(host='', port=3000): \"\"\" 启动服务器 \"\"\" # 初始化socket with socket.socket() as s: s.bind((host, port)) # 监听 接收 读取请求数据 while True: s.listen(5) connection, address = s.accept() request = connection.recv(1024).decode('utf-8') print('ip = &#123;&#125;\\nrequest = &#123;&#125;'.format(address, request)) try: # 得到HTTP请求的路径 path = request.split()[1] # 根据路径返回响应 responce = responce_for_path(path) # 响应给客户端(浏览器) connection.sendall(responce) except Exception as e: print('error', e) connection.closeif __name__ == \"__main__\": config = dict( host='', port=3000, ) run(**config)","categories":[{"name":"Web通信","slug":"Web通信","permalink":"http://yoursite.com/categories/Web通信/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"},{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"使用python 原生socket爬取豆瓣top250 (客户端)","slug":"使用python-原生socket爬取豆瓣top25","date":"2018-12-07T02:34:10.000Z","updated":"2018-12-07T08:39:11.884Z","comments":true,"path":"2018/12/07/使用python-原生socket爬取豆瓣top25/","link":"","permalink":"http://yoursite.com/2018/12/07/使用python-原生socket爬取豆瓣top25/","excerpt":"","text":"了解底层socket原理, 有助于理解网络知识这是一个客户端的编写。 socket通信流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108# 用原生socket实现一个具有基本功能的socket, 并抓取了豆瓣top250的数据import socketimport ssldef parse_url(url): \"\"\" 解析 url 返回 (protocol host port path) \"\"\" protocol = 'http' i = url.find('://') if i == -1: u = url else: protocol = url[0:i] u = url.split('://')[1] # 2. 解析host和path i = u.find('/') if i == -1: host = u path = '/' else: host = u[:i] path = u[i:] # 3.解析端口 port_dict = &#123; 'http': 80, 'https': 443, &#125; # 默认端口 port = port_dict[protocol] if ':' in host: h = host.split(':') host = h[0] port = int(h[1]) # print('protocol = &#123;&#125;\\nhost = &#123;&#125;\\nport = &#123;&#125;\\nsearch = &#123;&#125;\\n------------'.format(protocol, host, port, path)) return protocol, host, port, pathdef socket_by_protocol(protocol): \"\"\" 根据协议返回一个 socket 实例 \"\"\" if protocol == 'http': s = socket.socket() else: # HTTPS 协议需要使用 ssl.wrap_socket 包装一下原始的 socket s = ssl.wrap_socket(socket.socket()) return sdef response_by_socket(s): \"\"\" 参数是一个 socket 实例 返回这个 socket 读取的所有数据 \"\"\" response = b'' buffer_size = 1024 while True: r = s.recv(buffer_size) if len(r) == 0: break response += r return responsedef parse_responce(r): \"\"\" 解析responce, 返回一个(status_code, headers, body) \"\"\" headers, body = r.split('\\r\\n\\r\\n', 1) h = headers.split('\\r\\n') status_code = int(h[0].split(\" \")[1]) headers = &#123;&#125; for line in h[1:]: k, v = line.split(': ') headers[k] = v return status_code, headers, bodydef get(url): \"\"\" 用get访问一个url地址, 并返回响应(status_code, headers, body) \"\"\" protocol, host, port, path = parse_url(url) s = socket_by_protocol(protocol) s.connect((host, port)) request = 'GET &#123;&#125; HTTP/1.1\\r\\nhost: &#123;&#125;\\r\\nConnection: close\\r\\n\\r\\n'.format( path, host) s.send(request.encode('utf-8')) responce = response_by_socket(s).decode('utf-8') status_code, headers, body = parse_responce(responce) if status_code in [301, 302]: url = headers['Location'] return get(url) return status_code, headers, bodyif __name__ == \"__main__\": url = 'http://movie.douban.com/top250' status_code, headers, body = get(url) print(body)","categories":[{"name":"Web通信","slug":"Web通信","permalink":"http://yoursite.com/categories/Web通信/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"}]},{"title":"二叉树的三种遍历方式详解","slug":"二叉树的三种遍历方式详解","date":"2018-12-03T12:12:32.000Z","updated":"2018-12-03T13:26:47.934Z","comments":true,"path":"2018/12/03/二叉树的三种遍历方式详解/","link":"","permalink":"http://yoursite.com/2018/12/03/二叉树的三种遍历方式详解/","excerpt":"","text":"二叉树的遍历二叉树的遍历方式一般有四种： 先序遍历 中序遍历 后序遍历 层序遍历因为前三种遍历方式都是采用了递归的方法进行遍历, 这里只介绍前三种 图1： 先序遍历前序遍历:1.访问根节点。2.访问左子树。3.访问右子树 按照图1, 前序遍历的的遍历方式是 ABDECF 中序遍历前序遍历:1.访问左子树。2.访问根节点。3.访问右子树 按照图1, 中序遍历的遍历方式是 DBEACF 中序遍历的性质由于中序遍历总是把根结点放在左子树和右子树的中间, 因此只要知道根结点，就可以利用该性质还原出整颗二叉树 至于如何知道根结点，我们可以通过先序序列或者后序序列 因此：只要知道前序+中序或者中序+后序 我们就能还原二叉树 但是前序+中序 是做不到的 后序遍历后序遍历:1.访问左子树。2.访问右子树。 3.访问根节点。 按照图1, 中序遍历的遍历方式是 DEBFCA 重建二叉树给定后序序列和中序序列, 重建这颗二叉树 后序遍历: ACBFGED 中序遍历: ABCDEFG 先用手工试算出这个前序序列 第一步: 由后序遍历的最后一个元素知道整棵树最初的根节点为D 第二步:由中序序列知道左子树是｛A,B,C｝， 右子树是｛E,F,G｝ 重复一二两步，知道E是右子树的根节点，并存在右子树，没有左子树 反复套用一二两步规则，最终可得到整颗树 例题：PAT 1020 Tree Traversals （25 分）给定后序序列和中序序列，求层序序列 思路：还原整个二叉树，再层序遍历求解层序序列","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/二叉树/"},{"name":"二叉树的遍历","slug":"二叉树的遍历","permalink":"http://yoursite.com/tags/二叉树的遍历/"}]},{"title":"蓝桥杯历届试题 剪格子 Java实现","slug":"蓝桥杯历届试题-剪格子-Java实现","date":"2018-12-03T02:53:53.000Z","updated":"2018-12-03T02:59:53.943Z","comments":true,"path":"2018/12/03/蓝桥杯历届试题-剪格子-Java实现/","link":"","permalink":"http://yoursite.com/2018/12/03/蓝桥杯历届试题-剪格子-Java实现/","excerpt":"","text":"题目链接：http://lx.lanqiao.cn/problem.page?gpid=T27 这道题用深搜解决 注意点有几个地方 首先题目要求的是先输入列，再输入行(简直反人类！) 它说要从左上角开始搜，意味着vis[0][0]这个点一定要访问过 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Scanner;/** * 剪格子 * @author zmj * @create 2018/12/2 */public class Main &#123; static int[] X = &#123;0, 0, -1, 1&#125;, Y = &#123;1, -1, 0, 0&#125;; static int[][] map = new int[15][15]; static int[][] vis = new int[15][15]; static int n, m, total, min; public static void dfs(int a, int b, int sum, int pos) &#123; if (sum &gt; total / 2) &#123; return; &#125; else if (sum == total / 2) &#123; if (pos &lt; min &amp;&amp; vis[0][0] == 1) &#123; min = pos; &#125; return; &#125; for (int i = 0; i &lt; 4; i++) &#123; int p = a + X[i]; int q = b + Y[i]; if (p &gt;= 0 &amp;&amp; p &lt; n &amp;&amp; q &gt;= 0 &amp;&amp; q &lt; m &amp;&amp; vis[p][q] == 0) &#123; sum += map[p][q]; vis[p][q] = 1; dfs(p, q, sum, pos + 1); sum -= map[p][q]; vis[p][q] = 0; &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); m = in.nextInt(); n = in.nextInt(); total = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; map[i][j] = in.nextInt(); total += map[i][j]; &#125; &#125; min = Integer.MAX_VALUE; if(total % 2 == 0) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; vis[i][j] = 1; dfs(i, j, map[i][j], 1); vis[i][j] = 0; &#125; &#125; if (min == Integer.MAX_VALUE) &#123; System.out.println('0'); &#125; else &#123; System.out.println(min); &#125; &#125; else &#123; System.out.println('0'); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/tags/蓝桥杯/"},{"name":"深搜","slug":"深搜","permalink":"http://yoursite.com/tags/深搜/"}]},{"title":"使用GitHub和Hexo搭建博客","slug":"使用GitHub和Hexo搭建博客","date":"2018-11-29T05:31:46.000Z","updated":"2018-11-29T10:02:32.003Z","comments":true,"path":"2018/11/29/使用GitHub和Hexo搭建博客/","link":"","permalink":"http://yoursite.com/2018/11/29/使用GitHub和Hexo搭建博客/","excerpt":"","text":"1. 前言使用GitHub和Hexo搭建博客, 也就是本博客的搭建过程 2. 准备工作 我们要使用hexo这个框架来做我们的静态网页，因为是基于node.js开发的，所以我们安装好node.js 然后我们用github来做网站，所以要有github账号 最后我们把我们的静态网页传到github上，所以需要git 3. 使用hexohexo官方文档：https://hexo.io/zh-cn/docs/ 首先我们去官网下载node.js，安装一路next就可以了 打开命令行输入node.v，npm.v命令查看是否安装成功 然后我们创建一个目录（这个目录很重要，就是作为我们博客的目录） 打开命令行，进入我们创建的目录 输入npm命令，安装我们的Hexo 1npm install -g hexo-cli 然后初始化我们的博客 1hexo init blog 给博客新建一篇文章 1hexo new test_my_site 用generate命令生成静态文件，下面这个命令也可以缩写成hexo g 1hexo generate 用server命令启动服务器，下面这个命令也可以缩写成hexo s 1hexo server 然后就打开http://localhost:4000/预览我们的网站吧！ 4. 使用github创建好github账号 新建仓库，仓库名字一定要是你的用户名.github.io，把readme.md也勾选上，我的仓库名字就是zzzmj.github.io 创建成功后，打开仓库进入setting，一路往下翻，看到Github Pages标题，然后看到下面的Souce打开选项，选择master branch，再保存Sava 然后你通过https://你的用户名.github.io/访问就能看到效果了~~ 5. 使用git将网页推送到github上这里我简单介绍下git的安装和配置 安装好git以后呢，在我们的目录下右键打开Git Bash Here 输入命令，配置用户名和密码 12git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot; 生成ssh秘钥文件 这一步一定要做，我之前省事没做，发现更改主题的时候会有错误，不能将主题克隆下来 1ssh-keygen -t rsa -C &quot;你的邮箱&quot; 生成后，打开找到id_rsa.pub文件用记事本打开(这个文件目录git会告诉你)，然后复制全部内容 进入Github，打开我们用户的Setting，打开new SSH key 标题随便写，Key填入我们复制的内容，创建即可 打开我们本地博客根目录，找到_config.yml这个文件，它是我们的站点配置文件 打开这个文件，拉到最下面 1234deploy: type: git repo: 你的仓库名，复制下来就行 branch: master 然后我打开命令行，安装git部署插件 1npm install hexo-deployer-git --save 我们输入三条命令 123hexo clean hexo g hexo d clean命令是清除缓存的，这个命令可有可无 我们之间不是生成了静态文件吗，为什么这里还要使用hexo g命令呢，因为我们修改了配置文件，所以需要再更新一次 hexo d这条命令就是部署网站，是hexo deploy的缩写 大功告成，打开网站就能访问到了。 5. 更改主题更改主题挺方便的，我这里使用的主题是indigo 访问github里有详细的文档介绍，按照文档来就行 6. 怎么发布我们的文章看官方文档：https://hexo.io/zh-cn/docs/writing 7. 遇到的问题我在使用indigo主题的时候发现是一些文字日文，我们需要设置Hexo语言 将hexo 的 _config.yml 的 language:设定，设定为 zh-CN 访问tags和categories访问错误 Cannot GET /tags/ Cannot GET /categories/ 原因是我们没有配置tags和categories页面. 输入命令 12hexo new page tagshexo new page categories 修改 hexo/source/tags/index.md 的元数据 123layout: tagscomments: false--- 修改 hexo/source/categories/index.md 的元数据 123layout: categoriescomments: false---","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"搭建博客","slug":"搭建博客","permalink":"http://yoursite.com/tags/搭建博客/"}]},{"title":"test_my_site","slug":"test-my-site","date":"2018-11-26T02:22:16.000Z","updated":"2018-11-26T02:22:16.093Z","comments":true,"path":"2018/11/26/test-my-site/","link":"","permalink":"http://yoursite.com/2018/11/26/test-my-site/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-26T02:20:22.602Z","updated":"2018-11-26T02:20:22.603Z","comments":true,"path":"2018/11/26/hello-world/","link":"","permalink":"http://yoursite.com/2018/11/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}