{"meta":{"title":"你好,世界","subtitle":null,"description":null,"author":"zzzmj","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-12-20T11:52:24.000Z","updated":"2019-01-22T04:53:35.036Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"…"},{"title":"projects_url","date":"2018-12-20T11:52:51.000Z","updated":"2018-12-20T11:52:52.001Z","comments":true,"path":"projects-url/index.html","permalink":"http://yoursite.com/projects-url/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-29T09:48:42.000Z","updated":"2019-01-21T02:40:51.634Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-29T09:54:42.000Z","updated":"2019-01-21T02:41:09.096Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript 模拟实现call和apply","slug":"JavaScript-模拟实现call和apply","date":"2019-01-27T12:51:24.000Z","updated":"2019-01-27T13:13:14.847Z","comments":true,"path":"2019/01/27/JavaScript-模拟实现call和apply/","link":"","permalink":"http://yoursite.com/2019/01/27/JavaScript-模拟实现call和apply/","excerpt":"","text":"1. call和apply区别 简单概论：call 调用一个函数，并指定函数的this和参数列表apply 调用一个函数，并指定函数的this和参数数组 call和apply的区别就是 一个接收参数列表，一个接收参数数组 2. 分析由于两者区别不大，所以我们用call分析 例子123456789var obj = &#123; name: 'zmj'&#125;function sayName() &#123; console.log(this.name)&#125;sayName.call(foo) // 'zmj' 这个例子中可以看出call做了两件事 call改变了this的指向，指向了 foo bar函数执行 所以我们模拟实现的思路大致分为三步： 把函数设为对象的属性 执行该函数 删除该函数 3. call实现首先写出call的最简单版本12345Function.prototype.call = function(context) &#123; context.fn = this context.fn() delete context.fn&#125; 但我们还有情况没有考虑 call的第一个参数可以为null call可以给传参数 函数返回值 因此继续优化12345678910111213Function.prototype.callES3 = function(context) &#123; context = context || window context.fn = this var args = [] for (var i = 1; i &lt; arguments.length; i++) &#123; args.push('arguments[' + i + ']') &#125; var res = eval('context.fn(' + args + ')') delete context.fn return res&#125; 因为call后面的参数是不固定的，所以我们只能用arguments来获取 然后我们除去第一个参数，将剩余的参数保存到args数组中, 将参数拼接, 使用eval方法执行然后接收返回值 使用ES6的扩展表达式能把实现写的更漂亮简洁些12345678910Function.prototype.callES6 = function(context) &#123; context = context || window context.fn = this let args = [...arguments].slice(1) let res = context.fn(...args) delete context.fn return res&#125; 4. apply实现apply实现原理与call相同 这里给出apply实现 12345678910111213141516171819202122232425262728293031// apply ES3实现Function.prototype.applyES3 = function(context, arr) &#123; context = context || window context.fn = this var res if (arr) &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')'); &#125; else &#123; res = context.fn() &#125; return res&#125;// apply ES6实现Function.prototype.applyES6 = function(context, arr) &#123; context = context || window context.fn = this let res if (arr) &#123; res = context.fn(...arr) &#125; else &#123; res = context.fn() &#125; delete context.fn return res&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"call","slug":"call","permalink":"http://yoursite.com/tags/call/"},{"name":"apply","slug":"apply","permalink":"http://yoursite.com/tags/apply/"}]},{"title":"使用python爬取 ycxy-3000张证件照","slug":"使用python爬取-ycxy-3000张证件照","date":"2019-01-24T13:51:55.000Z","updated":"2019-01-24T14:36:14.039Z","comments":true,"path":"2019/01/24/使用python爬取-ycxy-3000张证件照/","link":"","permalink":"http://yoursite.com/2019/01/24/使用python爬取-ycxy-3000张证件照/","excerpt":"","text":"使用python爬取 ycxy-3000张证件照1. 前言之前在查普通话成绩的时候，发现需要只名字和身份证就能查到用户的的证件照 在学校的网站上，学生信息经常会被公开，比如四六级考试，或者防护性做的比较差的教务管理系统，很容易就能拿到同学的信息，于是我用爬虫爬拿到了学校一部分同学的证件照 2. 环境准备 chrome python 3 requests 网络库 os 本地存储 urllib.request 下载图片 json 临时存储数据 time 计算爬虫时间普通话成绩查询网址：http://www.cltt.org/studentscore3. 分析 打开F12开发者工具，观察到我们的表单数据通过post方式，提交给了/StudentScore/ScoreResult 打开开发者工具的NetWork选项，我们模拟一次发送数据 找到了ScoreResult我们看到post请求提交了三个数据name, stuID, idCard于是我们就可以使用requests 来模拟发送post请求了 然后分析html结构，发现图片在类名为user-img的span标签的子结点下 4. 代码4.1 爬取照片地址首先，我已经通过爬虫拿到了学生的信息并保存到了本地所以直接从本地读取json得到学生对象1234def get_stu_list(path): with open(path, 'r', encoding='utf-8') as f: stu_list = json.load(f) return stu_list 然后请求网站得到照片的地址，做了一些异常处理，因为有些同学可能没有去参加这个考试~ 123456789101112131415161718192021222324def get_image_url(name, id): if not name or not id: return \"\" url = 'http://www.cltt.org/StudentScore/ScoreResult' headers = &#123; \"User-Agent\": 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/71.0.3578.98 Safari/537.36' &#125; data = &#123; 'name': name, 'idCard': id &#125; try: res = requests.post(url, data=data, headers=headers).text except requests.ConnectionError: print(name + '查询异常') return \"\" doc = PyQuery(res) img_src = doc('.user-img').find('img').attr('src') if not img_src: return \"\" else: return img_src 然后通过学生数组，循环调用get_image_url，我们就可以拿到所有的照片地址 4.2 给图片分类保存到本地拿到照片地址之后，我们使用urlretrieve方法来下载图片 使用os.markdirs方法来创建文件夹并给图片分类 1234567891011121314def get_stu_list(path): with open(path, 'r', encoding='utf-8') as f: stu_list = json.load(f) for stu in stu_list: if not stu['img']: continue college = stu['college'] stu_class = stu['class'] directory = college + '/' + stu_class if not os.path.exists(directory): os.makedirs(directory) filename = '&#123;&#125;/&#123;&#125;/&#123;&#125;.jpeg'.format(college, stu_class, stu['name']) urlretrieve(stu['img'], filename=filename) return stu_list 5. 总结图片分两级目录，第一级是学院，第二级是班级学院目录： 班级目录： 其中一个班级： 爬取3164张照片一共花费了约20分钟 github：https://github.com/zzzmj/photo-crawler撒花，感谢你的观看，点个Star吧，Thanks♪(･ω･)ﾉ","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"}]},{"title":"欧拉函数及其计算","slug":"欧拉函数及其计算","date":"2019-01-22T13:11:29.000Z","updated":"2019-01-22T13:11:44.633Z","comments":true,"path":"2019/01/22/欧拉函数及其计算/","link":"","permalink":"http://yoursite.com/2019/01/22/欧拉函数及其计算/","excerpt":"","text":"欧拉函数1. 定义什么是欧拉函数？ 任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？） 计算这个值的方法就叫做欧拉函数，用φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。 2. 计算欧拉函数计算公式这个p是什么呢？ 一个正整数 n 可以通过分解质因数得到例如n = 100我们就可以写成 100 = 2^2 + 5^2 欧拉值 φ(n) = 100 * (1- 1/2) * (1 - 1/5) 那么知道了这个公式，我们怎么去计算呢 大致的几步找到因子将把(1- 1/p)转换为(p - 1) / p然后把相同的因子筛去 12345678910111213141516int euler(int n) &#123; int ans = n; for (int i = 2; i*i &lt;= ans; i++) &#123; if (n % i == 0) &#123; ans = ans / i * (i-1); // 将相同的因子除去 while (n % i == 0) &#123; n /= i; &#125; &#125; &#125; if (n &gt; 1) &#123; ans = ans / n * (n-1); &#125; return ans;&#125; 由于本文主要目的是讲如何计算，欧拉函数公式的推导过程可以参考维基百科：欧拉函数","categories":[],"tags":[]},{"title":"JS中typeof和instanceof的区别","slug":"JS中typeof和instanceof的区别","date":"2019-01-10T09:00:09.000Z","updated":"2019-01-10T09:00:32.102Z","comments":true,"path":"2019/01/10/JS中typeof和instanceof的区别/","link":"","permalink":"http://yoursite.com/2019/01/10/JS中typeof和instanceof的区别/","excerpt":"","text":"区别：typeof运算符用来检测基本数据类型使用方法：typeof opera或者typeof(operand) instanceof运算符用来检测对象类型（引用类型）准确些可以说：来判断某个对象是否是某个类的一个实例是则返回true，否则返回false使用方法：variable instanceof constructor 1. 基本数据类型typeof用来检测五种基本数据类型 string number boolean null undefined typeof检测null会返回object，这是语言本身的一个bug，因为null本身属于基本类型 一般不推荐使用typeof来检测引用类型 检测函数对象时会返回function其他对象时均返回object 2. 内置对象常见的内置对象 String Number Boolean Object Function Array Date RegExp 如果变量是给定引用类型的实例，那么instanceof操作符就会返回true 1234var a = []a instanceof Array // 变量a是Array类型吗?var b = &#123;&#125;b instanceof Object // 变量b是Object类型吗? 如果使用instanceof检测基本类型，那么操作符始终返回false，因为基本类型不是对象1234var a = 1var b = 'zmj'a instanceof Number // falseb instanceof String // false 参考资料：你不知道的JavaScript(上卷) JavaScript高级程序设计（第3版） typeof | MDN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"JavaScript函数中this的四种绑定策略","slug":"JavaScript函数中this的四种绑定策略","date":"2019-01-01T06:44:36.000Z","updated":"2019-01-01T10:03:24.796Z","comments":true,"path":"2019/01/01/JavaScript函数中this的四种绑定策略/","link":"","permalink":"http://yoursite.com/2019/01/01/JavaScript函数中this的四种绑定策略/","excerpt":"","text":"this的四种绑定策略 默认绑定 隐式绑定 显示绑定 new绑定 1. 默认绑定当一个函数没有明确的调用对象的时候，也就是单纯作为独立函数调用的时候，将对函数的this使用默认绑定：绑定到全局的window对象 123456// 第一个例子var foo = function() &#123; console.log(this.a);&#125;var a = 2foo() // 2 12345678910// 第二个迷惑性的例子var foo = function() &#123; var a = 3 var inner = function() &#123; console.log(this.a); &#125; inner()&#125;var a = 2foo() // 2 第二个例子虽然在foo()作用域内声明了a变量为3, 但它并不是一个对象, 所以this最终还是会指向全局的window对象 2. 隐式绑定函数被调用时有上下文对象，那么this会绑定这个上下文对象 书上写的上下文对象意思很模糊, 觉得这里翻译的其实不太好 我感觉比较好的解释是：当函数被一个对象包含的时候, 我们称这个函数的this被隐式绑定到这个对象上了 123456var o = &#123; a: 2, foo: function() &#123; console.log(this.a); &#125;,&#125; 在一串对象属性引用链中, this绑定的是最内层的对象 12345678910111213var obj = &#123; a: 1, obj2: &#123; a: 2, obj3: &#123; a:3, getA: function () &#123; console.log(this.a) &#125; &#125; &#125;&#125;obj.obj2.obj3.getA(); // 输出3 隐式丢失最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象, 也就是它会应用默认绑定, 把this绑定到全局对象或者undefined上 12345678910var foo = function() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo,&#125;var a = 5var bar = obj.foo bar() // 5 像这个例子, obj对象把foo函数的引用传给bar的时候, 会丢失this对obj的绑定 回调函数同样也会丢失绑定123456789var foo = function() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo,&#125;var a = 5setTimeout(obj.foo, 100) // 5 这种函数赋值的方式是无法将函数所绑定的this对象也传递过去的 3. 显式绑定显式绑定是通过apply或者call函数绑定的对象 如果你想传递函数并且把所绑定的this对象也传递过去, 那么就可以使用call() fn.call(object) fn是你调用的函数 object是你希望绑定的对象 作用：即刻调用函数fn(), 调用时这个函数的this指向object 12345678var foo = function() &#123; console.log(this.a)&#125;var obj = &#123; a: 1,&#125;foo.call(obj) 这样做有个缺点, 每次调用都会依赖call 所以可以将它包装成函数12345678910var foo = function() &#123; console.log(this.a)&#125;var obj = &#123; a: 1,&#125;var bar = function() &#123; foo.call(obj)&#125;bar() 如果使用bind会更简单12345678var foo = function() &#123; console.log(this.a)&#125;var obj = &#123; a: 1,&#125;var bar = foo.bind(obj)bar() call和bind的区别是：在绑定this到对象参数的同时： call将立即执行该函数 bind不执行函数，只返回一个可供执行的函数 4. new绑定来new来调用函数，会自动执行下列操作 创建一个全新的对象 这个新对象被执行[[prototype]]连接 这个新对象会绑定到函数调用的this 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象 123456function foo(a) &#123; this.a = a;&#125;var bar = new foo(2)console.log(bar.a) // 2 5. 优先级new绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 默认绑定在严格模式下会绑定到undefined, 否则绑定到全局对象 参考资料：你不知道的JavaScript(上卷)【javascript】函数中的this的四种绑定形式","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"this","slug":"this","permalink":"http://yoursite.com/tags/this/"},{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/函数/"}]},{"title":"for 循环中的setTimeout(function(){})异步问题","slug":"for-循环中的setTimeout-function-异步问题","date":"2018-12-20T11:12:44.000Z","updated":"2018-12-26T00:58:49.552Z","comments":true,"path":"2018/12/20/for-循环中的setTimeout-function-异步问题/","link":"","permalink":"http://yoursite.com/2018/12/20/for-循环中的setTimeout-function-异步问题/","excerpt":"","text":"阅读这段代码 12345for (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000)&#125; 预期是分别输出数字1-5, 每秒1次，每次1个结果却是每秒一次输出了5个6 setTimeout的执行原理setTimeout()是一个异步方法, 传递一个函数，延迟一段时候把该函数添加到队列当中，并不是立即执行,而且必须等当前环境所有代码执行完以后, 才会运行 也就是说我们执行这个for循环的时候12345setTimeout(fun(...), 1000)setTimeout(fun(...), 2000)setTimeout(fun(...), 3000)setTimeout(fun(...), 4000)setTimeout(fun(...), 5000) 五个函数先进入了队列, 然后等for循环结束后再依次出队 (粗略理解, 实质上是回调函数)for循环结束后, 此时i是等于6的, 所以每秒一次输出了5个6 要注意到var定义的i实质上是全局变量, 等同于下面的代码1234var ifor (i = 1; i &lt;= 5; i++) &#123; ...&#125; 解决办法使用闭包这个办法的原理是创建了闭包作用域, 每次循环会生成一个新的闭包作用域, 使得延迟函数回调可以访问到正确的值 注意, 闭包作用域里必须声明变量j, 如果是一个空的作用域, 那不会产生作用1234567for (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;, j*1000) &#125;)(i)&#125; 使用ES6中的let这个办法的原理是通过let来劫持块作用域, 注意, 这个变量i不只会声明一次, 每次迭代的时候都会声明i, 每次迭代后, i的值都会使用 上一个迭代的值来初始化这个变量, 形成一个块作用域 12345for (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000)&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/异步/"},{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/闭包/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"使用python 原生socket搭建简单服务器","slug":"使用python-原生socket搭建简单服务器","date":"2018-12-07T08:37:19.000Z","updated":"2018-12-07T08:47:39.514Z","comments":true,"path":"2018/12/07/使用python-原生socket搭建简单服务器/","link":"","permalink":"http://yoursite.com/2018/12/07/使用python-原生socket搭建简单服务器/","excerpt":"","text":"使用socket搭建简单的服务器socket通信流程 chrome浏览器模拟客户端, 访问该服务器, 显示文字和图片 其中值得注意的地方: 当我键入服务器地址访问时, chrome浏览器给服务器发送了四个http请求 请求1: 请求主页 GET / HTTP/1.1Host: localhost:3000 请求2: 请求图片 GET /doge.gif HTTP/1.1Host: localhost:3000 请求3：请求标签栏图标 GET /favicon.ico HTTP/1.1Host: localhost:3000 请求4：空请求 会导致程序报错, 需要捕获这个请求，因为会我写的responce_for_pat里没有响应空请求 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import socketdef route_index(): \"\"\" 主页的处理函数, 返回主页的响应 \"\"\" header = 'HTTP/1.x 200 OK\\r\\nContent-Type: text/html\\r\\n' body = '&lt;h1&gt;Hello World&lt;/h1&gt;&lt;img src=\"doge.gif\"/&gt;' r = header + '\\r\\n' + body return r.encode(encoding='utf-8')def route_img(): \"\"\" 图片的处理函数, 读取图片并生成响应返回 \"\"\" with open('doge.gif', 'rb') as f: header = b'HTTP/1.x 200 OK\\r\\nContent-Type: image/gif\\r\\n\\r\\n' img = header + f.read() return imgdef responce_for_path(path): \"\"\" 根据 path 调用相应的处理函数 没有处理的 path 会返回 404 \"\"\" r = &#123; '/': route_index, '/doge.gif': route_img, &#125; # 这里得到的是一个函数体 responce = r.get(path) return responce()def run(host='', port=3000): \"\"\" 启动服务器 \"\"\" # 初始化socket with socket.socket() as s: s.bind((host, port)) # 监听 接收 读取请求数据 while True: s.listen(5) connection, address = s.accept() request = connection.recv(1024).decode('utf-8') print('ip = &#123;&#125;\\nrequest = &#123;&#125;'.format(address, request)) try: # 得到HTTP请求的路径 path = request.split()[1] # 根据路径返回响应 responce = responce_for_path(path) # 响应给客户端(浏览器) connection.sendall(responce) except Exception as e: print('error', e) connection.closeif __name__ == \"__main__\": config = dict( host='', port=3000, ) run(**config)","categories":[{"name":"Web通信","slug":"Web通信","permalink":"http://yoursite.com/categories/Web通信/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"},{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"使用python 原生socket爬取豆瓣top250 (客户端)","slug":"使用python-原生socket爬取豆瓣top25","date":"2018-12-07T02:34:10.000Z","updated":"2018-12-07T08:39:11.884Z","comments":true,"path":"2018/12/07/使用python-原生socket爬取豆瓣top25/","link":"","permalink":"http://yoursite.com/2018/12/07/使用python-原生socket爬取豆瓣top25/","excerpt":"","text":"了解底层socket原理, 有助于理解网络知识这是一个客户端的编写。 socket通信流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108# 用原生socket实现一个具有基本功能的socket, 并抓取了豆瓣top250的数据import socketimport ssldef parse_url(url): \"\"\" 解析 url 返回 (protocol host port path) \"\"\" protocol = 'http' i = url.find('://') if i == -1: u = url else: protocol = url[0:i] u = url.split('://')[1] # 2. 解析host和path i = u.find('/') if i == -1: host = u path = '/' else: host = u[:i] path = u[i:] # 3.解析端口 port_dict = &#123; 'http': 80, 'https': 443, &#125; # 默认端口 port = port_dict[protocol] if ':' in host: h = host.split(':') host = h[0] port = int(h[1]) # print('protocol = &#123;&#125;\\nhost = &#123;&#125;\\nport = &#123;&#125;\\nsearch = &#123;&#125;\\n------------'.format(protocol, host, port, path)) return protocol, host, port, pathdef socket_by_protocol(protocol): \"\"\" 根据协议返回一个 socket 实例 \"\"\" if protocol == 'http': s = socket.socket() else: # HTTPS 协议需要使用 ssl.wrap_socket 包装一下原始的 socket s = ssl.wrap_socket(socket.socket()) return sdef response_by_socket(s): \"\"\" 参数是一个 socket 实例 返回这个 socket 读取的所有数据 \"\"\" response = b'' buffer_size = 1024 while True: r = s.recv(buffer_size) if len(r) == 0: break response += r return responsedef parse_responce(r): \"\"\" 解析responce, 返回一个(status_code, headers, body) \"\"\" headers, body = r.split('\\r\\n\\r\\n', 1) h = headers.split('\\r\\n') status_code = int(h[0].split(\" \")[1]) headers = &#123;&#125; for line in h[1:]: k, v = line.split(': ') headers[k] = v return status_code, headers, bodydef get(url): \"\"\" 用get访问一个url地址, 并返回响应(status_code, headers, body) \"\"\" protocol, host, port, path = parse_url(url) s = socket_by_protocol(protocol) s.connect((host, port)) request = 'GET &#123;&#125; HTTP/1.1\\r\\nhost: &#123;&#125;\\r\\nConnection: close\\r\\n\\r\\n'.format( path, host) s.send(request.encode('utf-8')) responce = response_by_socket(s).decode('utf-8') status_code, headers, body = parse_responce(responce) if status_code in [301, 302]: url = headers['Location'] return get(url) return status_code, headers, bodyif __name__ == \"__main__\": url = 'http://movie.douban.com/top250' status_code, headers, body = get(url) print(body)","categories":[{"name":"Web通信","slug":"Web通信","permalink":"http://yoursite.com/categories/Web通信/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"}]},{"title":"二叉树的三种遍历方式详解","slug":"二叉树的三种遍历方式详解","date":"2018-12-03T12:12:32.000Z","updated":"2018-12-03T13:26:47.934Z","comments":true,"path":"2018/12/03/二叉树的三种遍历方式详解/","link":"","permalink":"http://yoursite.com/2018/12/03/二叉树的三种遍历方式详解/","excerpt":"","text":"二叉树的遍历二叉树的遍历方式一般有四种： 先序遍历 中序遍历 后序遍历 层序遍历因为前三种遍历方式都是采用了递归的方法进行遍历, 这里只介绍前三种 图1： 先序遍历前序遍历:1.访问根节点。2.访问左子树。3.访问右子树 按照图1, 前序遍历的的遍历方式是 ABDECF 中序遍历前序遍历:1.访问左子树。2.访问根节点。3.访问右子树 按照图1, 中序遍历的遍历方式是 DBEACF 中序遍历的性质由于中序遍历总是把根结点放在左子树和右子树的中间, 因此只要知道根结点，就可以利用该性质还原出整颗二叉树 至于如何知道根结点，我们可以通过先序序列或者后序序列 因此：只要知道前序+中序或者中序+后序 我们就能还原二叉树 但是前序+中序 是做不到的 后序遍历后序遍历:1.访问左子树。2.访问右子树。 3.访问根节点。 按照图1, 中序遍历的遍历方式是 DEBFCA 重建二叉树给定后序序列和中序序列, 重建这颗二叉树 后序遍历: ACBFGED 中序遍历: ABCDEFG 先用手工试算出这个前序序列 第一步: 由后序遍历的最后一个元素知道整棵树最初的根节点为D 第二步:由中序序列知道左子树是｛A,B,C｝， 右子树是｛E,F,G｝ 重复一二两步，知道E是右子树的根节点，并存在右子树，没有左子树 反复套用一二两步规则，最终可得到整颗树 例题：PAT 1020 Tree Traversals （25 分）给定后序序列和中序序列，求层序序列 思路：还原整个二叉树，再层序遍历求解层序序列","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/二叉树/"},{"name":"二叉树的遍历","slug":"二叉树的遍历","permalink":"http://yoursite.com/tags/二叉树的遍历/"}]},{"title":"蓝桥杯历届试题 剪格子 Java实现","slug":"蓝桥杯历届试题-剪格子-Java实现","date":"2018-12-03T02:53:53.000Z","updated":"2018-12-03T02:59:53.943Z","comments":true,"path":"2018/12/03/蓝桥杯历届试题-剪格子-Java实现/","link":"","permalink":"http://yoursite.com/2018/12/03/蓝桥杯历届试题-剪格子-Java实现/","excerpt":"","text":"题目链接：http://lx.lanqiao.cn/problem.page?gpid=T27 这道题用深搜解决 注意点有几个地方 首先题目要求的是先输入列，再输入行(简直反人类！) 它说要从左上角开始搜，意味着vis[0][0]这个点一定要访问过 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Scanner;/** * 剪格子 * @author zmj * @create 2018/12/2 */public class Main &#123; static int[] X = &#123;0, 0, -1, 1&#125;, Y = &#123;1, -1, 0, 0&#125;; static int[][] map = new int[15][15]; static int[][] vis = new int[15][15]; static int n, m, total, min; public static void dfs(int a, int b, int sum, int pos) &#123; if (sum &gt; total / 2) &#123; return; &#125; else if (sum == total / 2) &#123; if (pos &lt; min &amp;&amp; vis[0][0] == 1) &#123; min = pos; &#125; return; &#125; for (int i = 0; i &lt; 4; i++) &#123; int p = a + X[i]; int q = b + Y[i]; if (p &gt;= 0 &amp;&amp; p &lt; n &amp;&amp; q &gt;= 0 &amp;&amp; q &lt; m &amp;&amp; vis[p][q] == 0) &#123; sum += map[p][q]; vis[p][q] = 1; dfs(p, q, sum, pos + 1); sum -= map[p][q]; vis[p][q] = 0; &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); m = in.nextInt(); n = in.nextInt(); total = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; map[i][j] = in.nextInt(); total += map[i][j]; &#125; &#125; min = Integer.MAX_VALUE; if(total % 2 == 0) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; vis[i][j] = 1; dfs(i, j, map[i][j], 1); vis[i][j] = 0; &#125; &#125; if (min == Integer.MAX_VALUE) &#123; System.out.println('0'); &#125; else &#123; System.out.println(min); &#125; &#125; else &#123; System.out.println('0'); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/tags/蓝桥杯/"},{"name":"深搜","slug":"深搜","permalink":"http://yoursite.com/tags/深搜/"}]},{"title":"使用GitHub和Hexo搭建博客","slug":"使用GitHub和Hexo搭建博客","date":"2018-11-29T05:31:46.000Z","updated":"2018-11-29T10:02:32.003Z","comments":true,"path":"2018/11/29/使用GitHub和Hexo搭建博客/","link":"","permalink":"http://yoursite.com/2018/11/29/使用GitHub和Hexo搭建博客/","excerpt":"","text":"1. 前言使用GitHub和Hexo搭建博客, 也就是本博客的搭建过程 2. 准备工作 我们要使用hexo这个框架来做我们的静态网页，因为是基于node.js开发的，所以我们安装好node.js 然后我们用github来做网站，所以要有github账号 最后我们把我们的静态网页传到github上，所以需要git 3. 使用hexohexo官方文档：https://hexo.io/zh-cn/docs/ 首先我们去官网下载node.js，安装一路next就可以了 打开命令行输入node.v，npm.v命令查看是否安装成功 然后我们创建一个目录（这个目录很重要，就是作为我们博客的目录） 打开命令行，进入我们创建的目录 输入npm命令，安装我们的Hexo 1npm install -g hexo-cli 然后初始化我们的博客 1hexo init blog 给博客新建一篇文章 1hexo new test_my_site 用generate命令生成静态文件，下面这个命令也可以缩写成hexo g 1hexo generate 用server命令启动服务器，下面这个命令也可以缩写成hexo s 1hexo server 然后就打开http://localhost:4000/预览我们的网站吧！ 4. 使用github创建好github账号 新建仓库，仓库名字一定要是你的用户名.github.io，把readme.md也勾选上，我的仓库名字就是zzzmj.github.io 创建成功后，打开仓库进入setting，一路往下翻，看到Github Pages标题，然后看到下面的Souce打开选项，选择master branch，再保存Sava 然后你通过https://你的用户名.github.io/访问就能看到效果了~~ 5. 使用git将网页推送到github上这里我简单介绍下git的安装和配置 安装好git以后呢，在我们的目录下右键打开Git Bash Here 输入命令，配置用户名和密码 12git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot; 生成ssh秘钥文件 这一步一定要做，我之前省事没做，发现更改主题的时候会有错误，不能将主题克隆下来 1ssh-keygen -t rsa -C &quot;你的邮箱&quot; 生成后，打开找到id_rsa.pub文件用记事本打开(这个文件目录git会告诉你)，然后复制全部内容 进入Github，打开我们用户的Setting，打开new SSH key 标题随便写，Key填入我们复制的内容，创建即可 打开我们本地博客根目录，找到_config.yml这个文件，它是我们的站点配置文件 打开这个文件，拉到最下面 1234deploy: type: git repo: 你的仓库名，复制下来就行 branch: master 然后我打开命令行，安装git部署插件 1npm install hexo-deployer-git --save 我们输入三条命令 123hexo clean hexo g hexo d clean命令是清除缓存的，这个命令可有可无 我们之间不是生成了静态文件吗，为什么这里还要使用hexo g命令呢，因为我们修改了配置文件，所以需要再更新一次 hexo d这条命令就是部署网站，是hexo deploy的缩写 大功告成，打开网站就能访问到了。 5. 更改主题更改主题挺方便的，我这里使用的主题是indigo 访问github里有详细的文档介绍，按照文档来就行 6. 怎么发布我们的文章看官方文档：https://hexo.io/zh-cn/docs/writing 7. 遇到的问题我在使用indigo主题的时候发现是一些文字日文，我们需要设置Hexo语言 将hexo 的 _config.yml 的 language:设定，设定为 zh-CN 访问tags和categories访问错误 Cannot GET /tags/ Cannot GET /categories/ 原因是我们没有配置tags和categories页面. 输入命令 12hexo new page tagshexo new page categories 修改 hexo/source/tags/index.md 的元数据 123layout: tagscomments: false--- 修改 hexo/source/categories/index.md 的元数据 123layout: categoriescomments: false---","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"搭建博客","slug":"搭建博客","permalink":"http://yoursite.com/tags/搭建博客/"}]},{"title":"test_my_site","slug":"test-my-site","date":"2018-11-26T02:22:16.000Z","updated":"2018-11-26T02:22:16.093Z","comments":true,"path":"2018/11/26/test-my-site/","link":"","permalink":"http://yoursite.com/2018/11/26/test-my-site/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-26T02:20:22.602Z","updated":"2018-11-26T02:20:22.603Z","comments":true,"path":"2018/11/26/hello-world/","link":"","permalink":"http://yoursite.com/2018/11/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}